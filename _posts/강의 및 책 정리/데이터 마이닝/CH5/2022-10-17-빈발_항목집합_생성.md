---
title: "빈발 항목집합 생성"
excerpt : 빈발 항목집합 생성에 대한 글입니다.
categories:
  - 데이터 마이닝
  - 머신러닝
  - 연관 분석
toc: true
---

# 빈발 항목집합 생성
---

그림 1은 $I=\{a,b,c,d,e\}$에 대한 항목집합 격자(lattice) 구조를 보여준다.

|![그림 1](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 1.png)|
|:--:|
|그림 1|

그림 1에서 보는 바와 같이 가능한 모든 항목집합 후보군을 생성하고 각각의 지지도 카운트를 측정해야한다.
그림 2는 그런 과정을 보여준다. 

|![그림 2](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 2.png)|
|:--:|
|그림 2|

그러나 이런 접근법은 $O(NMw)$의 계산 복잡도가 필요하므로 비용이 많이 들 수 있다. N은 트랜잭션의 수, $M=2^k-1$은 항목집합들의 경우의 수이고 w는 하나의 트랜잭션에 존재하는 항목들의 개수인 트랜잭션 폭(transiaction width)이다.

계산 복잡도를 줄이기 위한 3개의 주요 접근법들은 다음과 같다.

1. **후보 항목집합들의 개수(M)을 줄이기** 
2. **비교 횟수 줄이기** 
3. **트랜잭션들의 개수 줄이기** 

  후보 항목집합을 만들었을 때, 크기가 3이라고 해보자. 그럼 그림 2의 TID=1인 트랜잭션은 지지도 카운트를 할 필요가 없다. 그래서 항목집합의 길이보다 작은 것은 아예 제외하고 시작한다.


먼저 1번 방법부터 알아보겠다. 

<br/>

## Apriori 원리

Apriori 원리란, 만약 한 항목집합이 빈발하다고 여겨졌으면, 그것의 모든 부분 집합들도 빈발함을 의미한다. 아래 그림 3은 항목집합 $\{c,d,e\}$가 빈발하다고 여겨짐으로써 아래의 관련된
모든 부분집합들이 빈발 항목집합들로 여겨짐을 보여준다. 

|![그림 3](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 3.png)|
|:--:|
|그림 3|

사실 당연한 얘기다. $\{c,d,e\}$가 빈발하다는 것은 지지도 카운트가 threshold를 넘었다는 것이므로, 각 요소 c,d,e가 많은 트랜잭션에 포함된다는 이야기다. 
그렇다는 것은 c,d,e의 조합으로 이루어진 부분집합들은 무조건 포함된다는 뜻이 된다. 즉, 한 항목집합의 부분집합들은 부모 항목집합의 지지도를 절대 초과하지 못한다. 이런 성질을 지지도 척도의 **비-단조형(anti-monotone)**이라고 한다.
이것을 이용하면 **빈발 항목집합이 되지 못하는 경우엔 나머지 부분집합들을 전부 가지치기(pruning)할 수 있다는 것**이다.
그림 4는 그 예시를 보여준다.

|![그림 4](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 4.png)|
|:--:|
|그림 4|

이 방식을 **지지도-기반 가지치기(support-based pruning)**이라고 부른다.

<br/>

## Apriori 알고리즘

Apriori 알고리즘은 Apriori 원리를 통한 지지도-기반 가지치기를 사용한 최초의 연관 규칙 탐사 알고리즘이다. 
그림 6은 그림 5의 트랜잭션 데이터를 바탕으로 지지도 threshold를 60%로 가정(지지도 카운트 >= 3)한 가지치기 과정을 보여준다. 



|![그림 5](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 5.png)|
|:--:|
|그림 5|

|![그림 6](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 6.png)|
|:--:|
|그림 6|

왼쪽 테이블은 1-항목집합을 보여준다. 개수는 $\binom{6}{1}=6$이다. Cola와 Eggs는 지지도 카운트가 threshold를 넘지 못했으니 Apriori 원리에 의해 버리도록 하자. 

가운데 테이블은 남은 항목들을 이용해서 2-항목집합을 만들고 지지도 카운트를 측정한 모습이다. 가지치기를 하지 않았다면 2-항목집합의 개수는 $\binom{6}{2}=15$가 된다.
그러나 가지치기를 통해 $\binom{4}{2}=6$이 된다. {Beer,Bread}와 {Beer,Milk}는 지지도 카운트가 threshold를 넘지 못했으니 제거하자. 

오른쪽 테이블은 2-항목집합 4개로 3-항목집합을 만든 모습이다. Bread,Diapers,Milk가 겹쳐있기 때문에 만들 수 있는 3-항목집합은 1개이다. 
그러나 모든 항목들로 3-항목집합을 만든다면 개수는 $\binom{6}{3}=20$ 이다. 

자, 그럼 Apriori 가지치기 전략의 유효성을 판단해보자. 먼저 가지치기를 하지 않았을 때의 모든 k-항목집합(k=1,2,3)의 개수는 다음과 같다.

$$
\binom{6}{1} + \binom{6}{2} + \binom{6}{3} = 6+15+20 = 41
$$

Apriori 가지치기를 했을 때의 개수는 다음과 같다.

$$
\binom{6}{1} + \binom{4}{2} + 1 = 6+6+1 = 13
$$

그림 5의 간단한 예조차도 무려 68%의 감소를 보인다. 그림 6의 방식을 알고리즘으로 작성하면 다음과 같이 작성된다고 한다. 보기만 하고 넘어가자.

|![그림 7](\assets\images\다양한 공부\데이터마이닝\CH5\빈발_항목집합_생성\그림 7.png)|
|:--:|
|그림 7|

Apriori 알고리즘의 빈발 항목집합 생성 부분에는 2개의 중요한 특성이 있다.

1. **레벨별(level-wise) 알고리즘** <br/><br/>
  1-항목집합의 빈발 항목집합들을 찾고 다음으로 2-, 3-, ... Max- 의 최대 크기의 빈발 항목집합들을 찾을 때까지 **한 레벨씩**진행함을 의미한다.<br/><br/>
2. **생성 및 검사(generate-and-set) 전략**<br/><br/>
k+1 레벨의 새로운 후보 항목집합은 k 레벨에서 찾아진 빈발 항목집합에 의해 **생성**되고 지지도 카운트를 계산한 후, threshold를 사용해서 **검사**를 한다.
여기서 알고리즘에 필요한 총 반복 횟수는 $k_{max}+1$이고, $k_{max}$란 빈발 항목집합의 최대 크기를 얘기한다. <br/><br/>

<br/>

## 후보 생성과 가지치기

그림 7의 알고리즘에서 5번째 줄의 candidate-gen 함수와 6번째 줄의 candidate-prune 함수는 다음의 두가지 연산을 수행한다.

1. **후보 생성(candidate-get)** <br/><br/>
이 함수는 k번째 레벨에서 찾아진 빈할 k-항목집합을 기반으로 새로운 후보 (k+1)-항목집합을 생성한다.<br/><br/>
2. **후보 가지치기(candidate-prune)**<br/><br/>
이 함수는 지지도-기반 가지치기를 사용해 k 레벨에서 빈발하지 않은 부분집합을 가진 후보 k-항목집합들을 제거한다. 

### 후보 생성

