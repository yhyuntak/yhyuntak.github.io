---
title: "논문 공부: PVNet : Pixel-wise Voting Network for 6DoF Pose Estimation"
excerpt : DenseFusion 공부
categories:
  - 컴퓨터 비전
  - 논문 리뷰
toc: true

---

본 글은 논문 [PVNet](chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://arxiv.org/pdf/1812.11788.pdf)을 읽고 공부하는 글입니다.

---

# PVNet 개요 및 목표
---
PVNet의 새로운 점은 2D object keypoint들과 포즈 추정을 위한 수정된 PnP 알고리즘이다. 
PVNet(Pixel-wise Voting Network)는 2D keypoint들을 찾기 위해 RANSAC 같은 방법을 사용하여 겹쳐져있는 물체들에 강인함을 갖는다. RANSAC 기반 voting은 각각의 keypoint들의 spatial 확률 분포를 주며,
uncertainty-driven PnP로 6D pose를 예측하게끔 해준다.

PVNet의 목표는 이미지로부터 1) 물체들을 찾고, 2) 물체들의 3D orientation과 translation을 찾는 것이다. 

※ 여기서 6D pose란, 물체의 좌표 시스템에서 카메라 좌표 시스템까지의 rigid transformation (R;t)를 의미한다. R은 rotation, t는 translation vector를 의미한다.

물체 pose를 예측하는 것은 2단계로 이루어진다.
1. CNN을 사용해 2d 물체 keypoint들을 찾는 것
2. PnP 알고리즘을 사용해 6D pose 파라미터들을 계산하는 것

<br/><br/>
# 첫번째 단계 : Voting-based keypoint localization
---
|![그림 1](\assets\images\다양한 공부\논문\컴퓨터 비전\PVNet\keypointlocalization.png)|
|:--:|
|그림 1|

위 그림은 RGB 이미지에서 픽셀 마다의 물체 label들(d)과 unit vector(c)를 예측한다. 여기서 unit vector(c)는 각 물체에 포함되어있는 모든 픽셀에서 물체의 keypoint로의 direction을 표현한다.
우리는 이 direction들이 주어지면, RANSAC 기반 voting을 통해 keypoint에 대한 2D location과 confidence score의 가설(hypotheses)들을 생성한다. 이 가설들을 기반으로 우린 각각의 키포인트들에 대한 
spatial 확률 분포의 평균과 공분산을 예측한다. 

## Voting-based keypoint localization의 장점 

픽셀마다 direction들을 예측하는 것은 장점들이 있다.
* 네트워크가 물체들의 local 특징에 좀더 집중하게 해준다.
* 집중하게 해주므로 어수선한 배경의 효과를 덜 받게 해준다.
* 겹쳐져 있는 키포인트들을 잘 표현한다
* 심지어 화면 안을 벗어난 물체의 일부분만으로도 keypoint가 어디에 있을지 예측 가능하다.

PVNet은 이번 단계에서 semantic segmentation과 vector-field 예측을 수행한다. 
각각의 픽셀들이 (c),(d)에서 갖는 값들을 설명하기 위해, 대표적인 픽셀 p를 예시로 들자. 이 픽셀은 k번째 물체에 속해있다고 하자.

p는 semantic label k를 가질 것이고 픽셀 p에서 k번째 물체의 2D keypoint $x_k$까지의 direction을 표현하는 unit vector $v_k(p)$를 가진다.

$$
v_k(p) = \frac{x_k-p}{||x_k-p||_2}
$$

> **NOTE** : 사실 figure 2의 (d)는 완벽히 학습되었을 때의 unit vector들의 모습을 보여준다. 실제로 학습이 되지 않았다면 unit vector들이 한 점에 대해 모이지 않고 여러 방향으로 표현될 것이다.

## 2D keypoint를 추정하기 위한 과정

이제 k번째 물체의 정답 keypoint $x_k$를 추정하기 위해 하는 과정을 시작한다.

semantic labels과 unit vector들이 주어지면, 우린 RANSAC 기반 voting 방법에서 **keypoint hypotheses를 생성**한다.
방법은 다음과 같다. 
1. semantic label들을 사용하여 target object에 해당하는 pixel들을 찾는다.
2. 픽셀들 중에서 랜덤하게 2개의 pixel들을 선택한다.
3. 랜덤 pixel 2개를 이용해 교차점 (intersection)을 얻는데, 이를 hypothesis $h_{k,i}$로 지정한다.
4. 이런 hypothesis들을 N개 만들어서 정답 keypoint $x_k$의 후보군을 만든다. 
5. 마지막으로 object의 모든 픽셀들은 이 hypotheses에 대해 vote를 해서 voting score를 얻는다.

$h_{k,i}$의 voting score $w_{k,i}$는 다음과 같이 정의된다.

$$
w_{k,i} = \sum_{p\in O}  \circledcirc (\frac{(h_{k,i}-p)^T}{|| h_{k,i} - p||_2}v_k(p) >= \theta)
$$

* $\theta$는 0.99로 사용한다. 
* O는 k번째 물체에 속하는 모든 semantic label들을 의미한다. 
* $\circledcirc$는 indicator 함수를 나타낸다. $\theta$ 이상이라면 1을 그 외는 0을 표현하는 함수다. [출처](https://ko.wikipedia.org/wiki/%EC%A7%80%EC%8B%9C_%ED%95%A8%EC%88%98)

여기서 스코어 $w_{k_,}$의 의미를 얘기해보자. 
현재 픽셀 p에서 i번째 가설 $h_{k,i}$의 방향 유닛 벡터와 CNN을 통해 얻어진 unit vector $v_k(p)$의 내적을 하는 것이다. 0.99 이상이란 것은 거의 같은 방향을 가져야만 나오는 값이므로 
**스코어 $w_{k,i}$가 클수록 해당 가설 $h_{k,i}$가 k번째 물체의 2D 키포인트일 가능성이 높아지는 것**이다. 그래서 그림 1의 (e)의 밝은 부분이 높은 score를 갖는 가설을 의미한다.

> 여기도 이미 PVNet으로 학습된 상태를 가정하고 그림으로 표현한 것이다.

hypotheses들을 다 계산하면, 이미지에서의 키포인트들의 spatial 확률 분포를 만들 수 있다. figure 2(e)는 그 예를 보여준다..? f인데 오타가 아닐까 싶다..?
마지막으로, 계산된 가설들과 스코어들로 키포인트 $x_k$의 평균 $\mu_k$와 공분산 $\sum_k$를 구해보자. 이것들은 uncertainty-driven PnP에 사용된다.

$$
\mu_k = \frac{\sum_{i=1}^N w_{k,i}h_{k,i}}{\sum_{i=1}^N w_{k,i}}
$$

$$
\Sigma_k = \frac{\sum_{i=1}^N w_{k,i}(h_{k,i}-\mu_k)(h_{k,i}-\mu_k)^T}{\sum_{i=1}^N w_{k,i}} 
$$

## Keypoint selection

|![그림 2](\assets\images\다양한 공부\논문\컴퓨터 비전\PVNet\figure3.png)|
|:--:|
|그림 2|

keypoint들은 3D object model에 기반해서 정의되어야 한다. 기존의 방법들은 object의 3D bounding box의 8개의 코너점을 keypoint로써 사용한다. 그림 2의 (a)가 그 예시이다.
이 코너점들은 object pixel들로부터 멀리 떨어져 있는게 딱봐도 보인다. object pixel들과의 거리가 길수록 localization error가 커진다. 
왜냐하면 keypoint hypotheses는 object pixel에서 시작한 vector들을 사용해서 만들어지기 때문이다.
figure 3.(b)는 pvnet으로 만들어진 코너점 hypotheses이고, (c)는 물체 표면에서 선택된 keypoint를 나타낸다. 둘다 PVNet을 기반으로 생성된 것이다.
(c)에서 본 것처럼 object surface에서의 keypoint들은 보통 localization에서 더 작은 variance를 가진다.

> 아마 여기도 학습된 상태에서 hypotheses들이 어떻게 보여지는지 표현하는 것 같다. (b)는 corner point를 keypoint로 잡았기에 분산이 퍼진 것을 볼 수 있다. 
> 반면, (c)는 한 곳에 몰리는 것을 볼 수 있다. (낮은 분산)

그러므로 우리는 keypoint로 (b)를 사용하지 않고 (c)를 사용할 것이다. 
한편, PnP 알고리즘을 좀 더 stable하게 하려면 이 keypoint들은 object에 분산되어 있어야 한다.
위 2개의 요구사항(requirements)를 생각해서, 우리는 farthest point sampling(FPS) 알고리즘을 사용하여 K 개의 keypoints를 선택한다.
먼저, 우리는 object의 중심을 추가해서 keypoint set을 초기화한다. 그리고 반복해서 object surface에서 point를 찾는다. 
**매 반복마다 찾아지는 point는 현재 keypoint set에서 가장 멀리 있는 것**이다. 그리고 set의 size가 K개가 될 때까지 반복해서 point를 찾아 set에 추가한다.
section 5.3은 이 전략이 바운딩 박스의 코너점들을 사용하는 것보다 더 좋은 결과를 낸다는 것을 보여준다. 
우리는 또한 키포인트들의 수를 다르게 사용하여 결과를 확인해 보았고, 우리는 K = 8 일때가 가장 trade off를 지키며 좋은 결과를 냄을 확인했다.

<br/><br/>
# 두번째 단계 : Uncertainty-driven PnP
---
각 object에 대해 2D 키포인트 location들 K개가 주어지면, off-the-shelf PnP SOLVER를 사용한 PnP 문제를 풀어서 6D pose를 계산할 수 있다. 예를 들면 [39,33]에서 사용된 EPnP[24]가 있다.
그러나 많은 방법들이 다른 keypoints이 다른 confidence들과 uncertainty patterns을 가지고 있을지도 모른다는 사실을 무시한다. 이는 PnP 문제를 풀 때 고려되어야 한다.

section 3.1에서 소개했듯이, 우리의 voting 기반 방법은 각 keypoint들에 대해 spatial probability distribution을 예측한다.
예측된 mean $\mu_k$ 와 covariance $\Sigma_k$ 가 주어지면, ( k = 1, ... ,K ) 우린 (R,t)를 계산한다. Mahalanobis distance를 최소화 하는 R,t를 말이다.

$$
\min_{R,t} \sum_{i=1}^K (\tilde{x}_k - \mu_k )^T \Sigma_k^{-1}(\tilde{x}_k-\mu_k),\;\;\tilde{x}_k = \pi(RX_k+t)
$$

* $X_K$는 키포인트의 3D 좌표이다.
* $\tilde{x}_k$는 $X_k$의 2D projection 값이다.
* $\pi$는 perspective projection 함수이다.
* R,t는 4개의 키포인트를 사용해 EPnP로 계산된 값이다. 이 값들은 공분산 행렬이 가장 작은 trace를 가질때의 값들이다.

위 식을 풀땐, LM(Levenberg-Marquardt) 알고리즘을 쓴다. 왜냐하면 Mahalanobis distance를 최소화하는 R,t를 구하는 위 식은 nonlinear 하기 때문이다.
[11]에서 approximated sampson error를 최소화 함으로써 feature uncertainties를 생각하지만, 우리는 직접 reprojection error를 최소화 했다.

<br/><br/>
# 학습 전략
---

## unit vector 학습

우리는 unit vector들을 학습하기 위해 smooth loss $l_1$을 사용했다.([13]에서 제안된)

$$
l(w) = \sum_{k=1}^K \sum_{p\in O }l_1 (\Delta v_k(p;w)|_x)+l_1(\Delta v_k(p;w)|_y), \\
\Delta v_k(p;w) = \tilde{v}_k(p;w)-v_k(p)
$$

* w : PVNet의 파라미터
* $\tilde{v}_k$ : 예측된 unit vector
* $v_k$ : ground truth unit vector
* $\Delta v_k(p;w)\|_x,\Delta v_k(p;w)\|_y$ : $\Delta v_k$의 element들


> **NOTE** : 이 loss function의 의미를 살펴보자.
2D coordinate에선 vector가 (x,y)로 표현된다. 먼저 시그마가 2개가 있는데, 왼쪽의 시그마를 통해 이미지 속에서 segmentation된 k번째 object를 선택하고, 두번째 sigma로 넘어간다.
두번째 sigma는 선택된 object의 segmentation된 모든 pixel들을 하나씩 훑으면서 더해나갈거라는 의미이다.<BR/>
이제 smooth loss l1 으로 vector의 변화량을 측정할 것이다. 이때, x,y의 변화량을 따로 측정할 것인데, $|_x$는 element x에 대해, $|_y$는 element y에 대해 라는 의미이다.
$\tilde{v}_k$는 내가 네트워크를 통해 예측한 unit vector이다. 다시 말하자면, CNN 혹은 ResNet 같은 backbone 네트워크들로 얻어진 예측 벡터인데, 이 backbone네트워크를 parameter w라고 간단히 표현한 것이다.
그래서 backbone network를 통해 얻은 $\tilde{v}_k$와 ground truth인 $v_k$ 의 error를 x,y 따로 따로 loss로 구하고 더한다는 의미이다. <BR/>
결국 이 loss l(w)를 줄이게 되면 당연히 $\Delta v_k$가 줄어드는 것을 의미하게 될 것이고, 이것은 올바르게 unit vector를 추정해 나가는 과정이라고 볼 수 있다.

## Semantic segmentation 학습

이것은 간단하게 cross entropy를 loss function으로 사용했다고 한다.

## 과적합 방지

overfitting을 막기 위해, 저자들은 synthetic image들을 training set에 넣었다.
각 물체마다 10000장의 이미지를 render했다. 그리고 또 다른 10000장을 사용했는데, "cut and paste"라는 전략을 이용한 것인데 [10]에서 사용한 것이다.
데이터 augmentation을 위해 random cropping, resizing, rotation, color jittering을 사용했다. 초기 learning rate는 0.001이고 20 epoch마다 절반으로 줄여나갔다. 총 200epoch를 했다.
<br/><br/>





