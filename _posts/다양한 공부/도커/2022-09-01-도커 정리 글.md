---
title: "도커 정리 글"
excerpt : 도커를 공부하면서 기록하고 싶은 정보들을 쓰는 곳입니다.
categories:
  - 도커
toc: true
---
  

# 1. 도커에 대한 설명들

* **도커 이미지**
>컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다. 이미지의 이름은 [저장소의 이름]/[이미지의이름]:[태그] 형식으로 구성된다.

* **도커 컨테이너**
>이미지를 읽어와서 컨테이너 계층에 저장된다. 이미지를 읽어오는 것이므로, 컨테이너에서 변경사항이 있더라도 이미지는 영향을 받지 않는다. 그리고 중요한 점이 생성된 컨테이너들은 각각
독립적이므로 수정되어도 서로 영향을 받지 않으며, 호스트와도 분리되어 있기 때문에 호스트에도 영향을 미치지 않는다는 것이다.

* **도커 볼륨**
> 도커 컨테이너는 각각 정보를 저장하고 보존한다. 그래서 컨테이너를 삭제하게되면 그대로 정보는 홀라당 날아가버린다. 이를 방지하기 위해, 도커 볼륨을 사용하자. 
> 3가지의 방법이 있지만, 나는 docker volume을 사용해 데이터를 보존하는 것을 기억하려고 한다. (아래에 명령어가 있으니 ctrl+F로 [docker volume]을 찾을 것)

* **도커 네트워크**
> 도커는 각각의 컨테이너마다 내부 IP를 순차적으로 할당하되, 매번 이것은 재시작할때마다 바뀐다. IP가 할당되면, 호스트에는 veth(virtual ethernet)이라는 네트워크 인터페이스가 생성된다.

<br/><br/><br/>

- - -

# 2. 도커 명령어들

1. **도커 버전 확인**
```python
docker -v
```

2. **기본적인 도커 run** (컨테이너와 상호작용(interaction)이 되며 터미널을 사용할 수 있게 해주는)
```python
docker run -i -t --name [컨테이너 이름] [이미지 이름]:[버젼]
```
* -i -t 옵션이 적혀 있어야 함.
* 이미지가 없을 경우, 도커 공식 이미지 저장소에서 이미지를 받아오는 pull이 자동으로 실행됨.
* docker start와 docker attach가 자동으로 실행됨.

3. **도커 run 쪼개기** (create -> start -> attach)
```python
docker create --name [컨테이너 이름] [이미지 이름]:[버젼]
docker start [컨테이너 이름]
docker attach [컨테이너 이름]
```

7. **실행중인 컨테이너 종료하기**
```python
docker stop [컨테이너 이름]
```

9. **컨테이너 목록 확인**
```python
docker ps
```
* 그냥 ps만 사용하면 실행중인 컨테이너들을 출력한다.
* 모든 컨테이너를 출력하기 위한 옵션 : -a
* 컨테이너의 ID만 출력하는 옵션 : -q

5. **컨테이너 이름 재설정**
```python
docker rename [원래 이름] [바꿀 이름]
```

6. **컨테이너 삭제**
```python
docker rm [컨테이너 이름]
```
* 단, 실행중인 컨테이너는 삭제가 불가능하다. 강제로 삭제하기 위해선 -f를 붙이자.

10. **많은 컨테이너 삭제**
```python
docker container prune
```

11. **도커 컨테이너를 외부와 연결하기** 
```python
docker run -i -t --name [컨테이너 이름] -p [호스트의 포트]:[컨테이너의 포트] [이미지 이름]:[이미지 버젼]
```
* -p 옵션을 사용함으로써 호스트의 포트와 컨테이너의 포트를 바인딩함.
* -p를 여러번 사용해서 다중 포트 개방 가능
>내가 네트워크쪽 지식은 부족하지만.. 이해한 바를 기록하면, 위 방식대로 도커 컨테이너의 포트를 내 호스트의 포트와 바인딩해야 외부에서 [내 호스트 ip]:[바인딩된 포트]로 컨테이너의 웹 서버에 접근이 가능하다.
>그리고 포트마다 설정을 줄 수 있는데, 기본으로 사용가능한 port가 80이다. 따라서 port 80에 연결했다면, 주소를 [호스트 ip]:[바인딩된 포트]를 적지 않고 [호스트 ip]만 입력하더라도 접속이 가능하다.

12. **컨테이너를 foreground로 실행하기(detach)**
```python
docker run -d ...(other options)
```
* -d를 붙임으로써 컨테이너가 foreground로 실행된다.
* -i -t 와 다른 점은, -i -t는 우리가 terminal을 사용해 입출력을 컨테이너와 주고 받을 수 있게 해주었으나, -d는 컨테이너의 터미널이 프로그램을 foreground로 바로 작동되게 하기 때문에 입출력을 주고받을 수 없다.
* Detached 모드인 컨테이너는 반드시 프로그램과 같이 실행되고 따로 종료될 수 없다.

13. **컨테이너 내부의 환경변수 설정**
```python
docker -e A=B
```
* 컨테이너 내부의 A라는 환경변수를 B로 설정하는 명령어

14. **컨테이너간의 연결법**
```python
docker --link [연결할 컨테이너 이름]:[그 컨테이너의 별명] ...(other options)
```
* 컨테이너간의 연결을 NAT ip를 통해 할 수 있지만, 매번 컨테이너의 ip가 재설정되기 때문에 고정값을 쓰기 어렵다. 따라서 컨테이너의 별명(컨테이너의 호스트명)으로 접근 가능하게 해주는 명령어.

15. **도커 볼륨 생성(create), 리스트(ls), 사용하지 않는 볼륨 삭제(prune)**
```python
docker volume create --name [볼륨 이름]
docker volume ls
docker volume prune
```
* 위 명령어를 이용해서 로컬 저장소에 도커 볼륨을 생성할 수 있다. 이는 도커 엔진에 의해 관리된다.
* 도커 볼륨을 쓰는 사용자는 볼륨이 어디에 저장되었는지 굳이 알 필요가 없다고 한다.
* 컨테이너를 삭제해도 볼륨은 삭제되지 않는다. 사용하지 않는 것을 전부 정리할꺼면, prune을 사용해 편하게 지우자. 
16. **도커 볼륨 사용법 예시**
```python
docker run -i -t --name [컨테이너 이름] -v [볼륨 이름]:[저장 디렉터리] [이미지 이름]:[이미지 버젼]
```
* 위 디렉토리에 파일을 생성한 후, 다른 컨테이너를 해당 도커 볼륨을 사용하면 방금 생성한 파일을 새로운 컨테이너에서도 볼 수 있다. 
* 굳이 [볼륨 이름]:[저장 디렉터리] 를 사용하지 않고, [저장 디렉터리]만을 써도 된다. 단, 매번 새로운 도커 볼륨이 생성되는 듯하다.

17. **도커 네트워크 목록(ls), 도커 네트워크의 브릿지 생성(create)**
```python
docker network ls
docker network create --driver [드라이버 타입] [네트워크 이름]
```

18. **도커 네트워크 사용법 예시(브릿지,호스트,논)**
```python
docker run -i -t --name [컨테이너 이름] --net [네트워크 이름] [이미지 이름]:[이미지 버젼]
docker run -i -t --name [컨테이너 이름] --net host [이미지 이름]:[이미지 버젼]
docker run -i -t --name [컨테이너 이름] --net none [이미지 이름]:[이미지 버젼]
```
* 호스트를 사용하면 별도의 포트 포워딩 없이 바로 컨테이너 내부의 어플리케이션에 접속가능하다.
* 논은 말그대로 네트워크를 사용하지 않음을 뜻한다.

19. **다른 컨테이너의 네트워크 환경 가져오기**
```python
docker run -i -t --net container:[네트워크 환경을 가져올 다른 컨테이너 이름] ...(other options)
```
* 위 방식을 사용하면, 다른 컨테이너의 네트워크 환경과 같게 새로운 컨테이너를 설정할 수 있다.
