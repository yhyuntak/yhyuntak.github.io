---
title: "도커 정리 글"
excerpt : 도커를 공부하면서 기록하고 싶은 정보들을 쓰는 곳입니다.
categories:
  - 도커
toc: true
---
  

# 1. 도커에 대한 설명들

* **도커 이미지**
>컨테이너를 생성하고 실행할 때 읽기 전용으로 사용된다. 이미지의 이름은 [저장소의 이름]/[이미지의이름]:[태그] 형식으로 구성된다.

* **도커 컨테이너**
>이미지를 읽어와서 컨테이너 계층에 저장된다. 이미지를 읽어오는 것이므로, 컨테이너에서 변경사항이 있더라도 이미지는 영향을 받지 않는다. 그리고 중요한 점이 생성된 컨테이너들은 각각
독립적이므로 수정되어도 서로 영향을 받지 않으며, 호스트와도 분리되어 있기 때문에 호스트에도 영향을 미치지 않는다는 것이다.

* **도커 볼륨**
> 도커 컨테이너는 각각 정보를 저장하고 보존한다. 그래서 컨테이너를 삭제하게되면 그대로 정보는 홀라당 날아가버린다. 이를 방지하기 위해, 도커 볼륨을 사용하자. 
> 3가지의 방법이 있지만, 나는 docker volume을 사용해 데이터를 보존하는 것을 기억하려고 한다. (아래에 명령어가 있으니 ctrl+F로 [docker volume]을 찾을 것)

* **도커 네트워크**
> 도커는 각각의 컨테이너마다 내부 IP를 순차적으로 할당하되, 매번 이것은 재시작할때마다 바뀐다. IP가 할당되면, 호스트에는 veth(virtual ethernet)이라는 네트워크 인터페이스가 생성된다.

<br/><br/><br/>

- - -

## 도커 명령어들

1. **도커 버전 확인**
```python
docker -v
```

2. **기본적인 도커 run** (컨테이너와 상호작용(interaction)이 되며 터미널을 사용할 수 있게 해주는)
```python
docker run -i -t --name [컨테이너 이름] [이미지 이름]:[버젼]
```
* -i -t 옵션이 적혀 있어야 함.
* 이미지가 없을 경우, 도커 공식 이미지 저장소에서 이미지를 받아오는 pull이 자동으로 실행됨.
* docker start와 docker attach가 자동으로 실행됨.

3. **도커 run 쪼개기** (create -> start -> attach)
```python
docker create --name [컨테이너 이름] [이미지 이름]:[버젼]
docker start [컨테이너 이름]
docker attach [컨테이너 이름]
```

7. **실행중인 컨테이너 종료하기**
```python
docker stop [컨테이너 이름]
```

9. **컨테이너 목록 확인**
```python
docker ps
```
* 그냥 ps만 사용하면 실행중인 컨테이너들을 출력한다.
* 모든 컨테이너를 출력하기 위한 옵션 : -a
* 컨테이너의 ID만 출력하는 옵션 : -q

5. **컨테이너 이름 재설정**
```python
docker rename [원래 이름] [바꿀 이름]
```

6. **컨테이너 삭제**
```python
docker rm [컨테이너 이름]
```
* 단, 실행중인 컨테이너는 삭제가 불가능하다. 강제로 삭제하기 위해선 -f를 붙이자.

10. **많은 컨테이너 삭제**
```python
docker container prune
```

11. **도커 컨테이너를 외부와 연결하기** 
```python
docker run -i -t --name [컨테이너 이름] -p [호스트의 포트]:[컨테이너의 포트] [이미지 이름]:[태그]
```
* -p 옵션을 사용함으로써 호스트의 포트와 컨테이너의 포트를 바인딩함.
* -p를 여러번 사용해서 다중 포트 개방 가능
>내가 네트워크쪽 지식은 부족하지만.. 이해한 바를 기록하면, 위 방식대로 도커 컨테이너의 포트를 내 호스트의 포트와 바인딩해야 외부에서 [내 호스트 ip]:[바인딩된 포트]로 컨테이너의 웹 서버에 접근이 가능하다.
>그리고 포트마다 설정을 줄 수 있는데, 기본으로 사용가능한 port가 80이다. 따라서 port 80에 연결했다면, 주소를 [호스트 ip]:[바인딩된 포트]를 적지 않고 [호스트 ip]만 입력하더라도 접속이 가능하다.

12. **컨테이너를 foreground로 실행하기(detach)**
```python
docker run -d ...(other options)
```
* -d를 붙임으로써 컨테이너가 foreground로 실행된다.
* -i -t 와 다른 점은, -i -t는 우리가 terminal을 사용해 입출력을 컨테이너와 주고 받을 수 있게 해주었으나, -d는 컨테이너의 터미널이 프로그램을 foreground로 바로 작동되게 하기 때문에 입출력을 주고받을 수 없다.
* Detached 모드인 컨테이너는 반드시 프로그램과 같이 실행되고 따로 종료될 수 없다.

13. **컨테이너 내부의 환경변수 설정**
```python
docker -e A=B
```
* 컨테이너 내부의 A라는 환경변수를 B로 설정하는 명령어

14. **컨테이너간의 연결법**
```python
docker --link [연결할 컨테이너 이름]:[그 컨테이너의 별명] ...(other options)
```
* 컨테이너간의 연결을 NAT ip를 통해 할 수 있지만, 매번 컨테이너의 ip가 재설정되기 때문에 고정값을 쓰기 어렵다. 따라서 컨테이너의 별명(컨테이너의 호스트명)으로 접근 가능하게 해주는 명령어.

15. **도커 볼륨 생성(create), 리스트(ls), 사용하지 않는 볼륨 삭제(prune)**
```python
docker volume create --name [볼륨 이름]
docker volume ls
docker volume prune
```
* 위 명령어를 이용해서 로컬 저장소에 도커 볼륨을 생성할 수 있다. 이는 도커 엔진에 의해 관리된다.
* 도커 볼륨을 쓰는 사용자는 볼륨이 어디에 저장되었는지 굳이 알 필요가 없다고 한다.
* 컨테이너를 삭제해도 볼륨은 삭제되지 않는다. 사용하지 않는 것을 전부 정리할꺼면, prune을 사용해 편하게 지우자. 
16. **도커 볼륨 사용법 예시**
```python
docker run -i -t --name [컨테이너 이름] -v [볼륨 이름]:[저장 디렉터리] [이미지 이름]:[태그]
```
* 위 디렉토리에 파일을 생성한 후, 다른 컨테이너를 해당 도커 볼륨을 사용하면 방금 생성한 파일을 새로운 컨테이너에서도 볼 수 있다. 
* 굳이 [볼륨 이름]:[저장 디렉터리] 를 사용하지 않고, [저장 디렉터리]만을 써도 된다. 단, 매번 새로운 도커 볼륨이 생성되는 듯하다.

17. **도커 네트워크 목록(ls), 도커 네트워크의 브릿지 생성(create)**
```python
docker network ls
docker network create --driver [드라이버 타입] [네트워크 이름]
```

18. **도커 네트워크 사용법 예시(브릿지,호스트,논)**
```python
docker run -i -t --name [컨테이너 이름] --net [네트워크 이름] [이미지 이름]:[태그]
docker run -i -t --name [컨테이너 이름] --net host [이미지 이름]:[태그]
docker run -i -t --name [컨테이너 이름] --net none [이미지 이름]:[태그]
```
* 호스트를 사용하면 별도의 포트 포워딩 없이 바로 컨테이너 내부의 어플리케이션에 접속가능하다.
* 논은 말그대로 네트워크를 사용하지 않음을 뜻한다.

19. **다른 컨테이너의 네트워크 환경 가져오기**
```python
docker run -i -t --net container:[네트워크 환경을 가져올 다른 컨테이너 이름] ...(other options)
```
* 위 방식을 사용하면, 다른 컨테이너의 네트워크 환경과 같게 새로운 컨테이너를 설정할 수 있다.

20. **도커 이미지 생성 과정 (컨테이너 생성 -> 이미지 커밋)**
```python
docker run -i -t --name [컨테이너 이름] [이미지 이름]:[태그]
docker commit -a [작성자 이름] -m [커밋 메시지] [커밋할 컨테이너 이름] [커밋될 이미지 이름]:[태그]
```
* 위 과정을 거치면 docker images를 통해 내가 생성한 이미지를 볼 수 있다.

21. **도커 조사법(inspect)**
```python
docker inspect [이름(컨테이너,이미지..)] --type [타입 명]
```
* inspect를 사용해 내가 갖고있는 도커 정보에 대해 알아볼 수 있다. 이 때, 이름이 중복될 경우가 있는데 그땐 컨테이너가 먼저 실행되므로 
타입 명을 항상 기재하는 습관을 들이자.

22. **도커 이미지의 commit들 보기**
```python
docker history [이미지 이름]:[태그]
```
* 도커 이미지는 레이어로 층층이 쌓여있는데, history를 사용하면 그동안 해당 이미지에 어떤 commit들이 들어가있는지 알 수 있다.

23. **도커 이미지 저장 및 로드**
```python
docker save -o [저장할 파일명] [이미지 이름]:[태그]
docker load -i [로드할 파일명]
```

24. **도커 태그**
```python
docker tag [기존의 이미지 이름]:[태그] [새롭게 생성될 이미지 이름]:[태그]
```
* 도커 태그를 사용하면 같은 이미지를 가르키는 새로운 이미지를 만들 뿐이다.

25. **도커 푸시 및 풀**
```python
docker push [저장소 이름]/[이미지 이름]:[태그]
docker pull [저장소 이름]/[이미지 이름]:[태그]
```
* 도커 태그 혹은 이미지 커밋 과정에서 반드시 [저장소 이름]을 가진 이미지를 가져야한다. 그래야 도커 푸시를 이용해서 도커 허브에 있는 나의 레포지토리에 업로드가 가능하기 때문.
* 여기서 중요한 점은 내가 만약 이미 도커 허브에 올려진 이미지를 기반으로 새로운 레이어를 쌓아서 새로운 이미지를 만들었다면, 내가 쌓인 레이어만 푸쉬됨을 볼 수 있다는 것이다.

26. 도커 빌드를 통한 이미지 생성
```python
docker build -t [생성될 이미지 이름]:[태그] -f [Dockerfile의 이름] [Dockerfile이 있는 위치] 
```


<br/><br/><br/>

# 2. Dockerfile
도커 이미지를 만들때, 우리는 기본 베이스 이미지(ex:ubuntu)로 컨테이너를 생성하고 환경을 설치하고 프로젝트를 넣고 이미지를 커밋하는 방식을 사용할 수 있다. 
그러나 이것은 애플리케이션을 컨테이너화하기 위한 장기적인 시점에서 본다면 좋지 않다고 한다. 그래서 나온 방법이 **Dockerfile** 이다.

**Dockerfile**은 이미지를 생성하기 위해서, 하나의 파일에 컨테이너에 설치해야할 패키지,소스코드,명령어 등을 적어 필요할 때 build를 통해 컨테이너에서 작업을 진행하게 해주는 파일이다.
**.dockerignore**로 이미지를 생성할 때, 디렉터리 내의 무시하거나 무시하지 말아야할 파일들을 지정해줄 수 있다. 

## Dockerfile 명령어
* **FROM [이미지 이름]**: 생성할 이미지의 베이스가 될 이미지
* **MAINTAINER [개발자 정보]**: 이미지를 생성한 개발자의 정보
* **LABEL "[키]:[값]"**: 이미지에 메타데이터를 추가
* **RUN [명령어]**: 이미지를 만들기 위해 컨테이너 내부에서 명령어 실행 (명령어에 git clone [주소] 를 쓸 수도 있다.)
> 여기서 apt-get install로 패키지를 설치시 도중에 항목 선택을 하는 패키지가 존재할 수 있다. 그럴땐, **ARG DEBIAN_FRONTEND=noninteractive** 를 추가해주자. 
* 
* **ADD [폴더 내의 파일 이름] [이미지 내부 디렉터리]**: 폴더 내의 파일을 이미지의 디렉터리에 저장
* **WORKDIR [명령어를 실행할 위치]** : 명령어를 실행할 위치를 설정
* **EXPOSE [포트]** : 빌드로 생성된 이미지에서 노출할 포트를 설정
* **CMD [명령어]** : 컨테이너가 시작될 때마다 실행할 명령어를 설정함. Dockerfile에서 한 번만 사용 가능.
* 