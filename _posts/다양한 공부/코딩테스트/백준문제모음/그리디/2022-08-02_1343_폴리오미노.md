---
title: "1343 폴리오미노"
excerpt : 배수를 갖고 노는 그리디 문제.
categories:
  - 코딩테스트
  - 그리디
toc: true
---
  
# 1. 문제
문제는 [링크](https://www.acmicpc.net/problem/1343)에 들어가면 있다.

# 2. 정답 코드

문제의 내 정답 코드는 다음과 같다.

```python
def solution():

    input_list = list(input().split())

    # 하나씩 확인하면서, X인 부분들을 찾는 느낌.
    save_space = []
    result_list = []
    count = 0
    for idx,t in enumerate(input_list[0]) :
        # . 를 만나면 어떤 작업을 하자.
        if t == '.' :
            
            result = []
            if count % 2 == 1 :
                return -1
            # 사전순으로 빠르게 배열해야하니 A가 무조건 앞에 와야댐.
            # 그럴려면 count가 4로 나눴을 때 몫이 존재해야함.
            # 그만큼 AAAA를 넣어주면 됨.
            if count > 0 :
                four = count//4
                two = (count-four*4)//2
                four_list = ['AAAA' for _ in range(four)]
                two_list = ['BB' for _ in range(two)]

                result.append(''.join(four_list))
                result.append(''.join(two_list))
            result.append('.')
            result_list.append(''.join(result))
            count = -1
        count+=1

        if idx == len(input_list[0])-1 :

            result = []
            if count % 2 == 1 :
                return -1
            # 마지막에 .을 못만나고 끝날수도. 그럼 그땐 이렇게
            four = count//4
            two = (count-four*4)//2
            four_list = ['AAAA' for _ in range(four)]
            two_list = ['BB' for _ in range(two)]

            result.append(''.join(four_list))
            result.append(''.join(two_list))
            result_list.append(''.join(result))
    last_result = ''.join(result_list)
    return last_result
print(solution())

```

<br/><br/><br/>

# 3. 풀이 및 생각

<br/>

## 문제 풀이

이 문제의 핵심은 X의 개수가 4로 먼저 나눠지는지, 그리고 남은 숫자가 2로 나눌 수 있는지 파악하기,
.을 만났을 때 문제 처리를 어떻게 할 것인지이다.

나 같은 경우엔 X의 개수를 세면서 반복문을 진행하다가, .을 만나거나 끝났을 때 count의 개수가 홀수면 
-1을 반환했다. 아닐 경우, X의 개수에 따라 AAAA와 BB를 배치했다. 

<br/> 

## 나의 생각

이 문제 자체는 그렇게 어려운 문제가 아니지만 약간의 구현 문제 비슷했다. 당황하지 않고
조건을 잘 따진다면 쉽게 풀 수 있는 문제다.