---
title: "코딩테스트 준비를 위한 과정"
categories:
  - 코딩테스트
toc: true
---

# 기본적으로 알아야 할 것
1. 최대한 for 문을 사용하지 않는 것이 시간적으로 이득이다.
2. numpy를 이용하지 못할 때가 있을 수도 있다. 그때는 대비하여 파이썬의 
기본 라이브러리들에 대해 빠삭하게 공부하자. [링크](https://docs.python.org/ko/3.8/library/index.html)
 * 자주쓰는 **random, sort** 등을 항상 생각하자.
 * 5 2 처럼 입력을 받을 때 n,m = map(int,input().split()) 를 사용하자.
 * 기본 함수 중 min, max를 잘 활용하고, 기본적인 문법은 다음과 같다. 
 ```python
  min(a) # 리스트 a에서 가장 작은 수를 추출
  min(a,b) # 실수 a,b 중 작은 놈을 추출
  max(a) # 리스트 a에서 가장 작은수를 추출
  max(a,b) # 실수 a,b 중 큰 놈을 추출
 ```
 
3. 파이썬은 메모리 제한을 고려하려면 만약 int형 데이터의 list의 길이가 1000만이 되면 메모리는 40MB를 잡아먹는 것을 알자.
4. 파이썬의 계산시간을 고려하려면 대충 1초에 2000만번의 연산을 수행한다고 생각하자. 특히 제한시간이 1초인데 데이터의 개수가 100만개 정도이면 시간 복잡도는 O(NlogN)이내의 알고리즘으로 문제를 풀어야한다. 따라서 시간제한과 데이터의 개수를 먼저 확인한 다음에 어느정도의 시간 복잡도의 알고리즘으로 문제를 풀지 예측하는 습관을 가져야한다.
5. for문을 쓸때 for i in range(start,end,step) 에서 step을 정해주면 step단위로 for문이 돌아가고, step에 -1을 하면 역으로 작아진다.
6. 입력데이터의 수가 많으면 sys라이브러리의 readline()을 사용하자.
---
# 알고리즘별 정리

## 그리디 및 시뮬레이션

1. 문제 유형을 바로 파악하기 어려우면 그리디 알고리즘을 의심하고 문제해결을 위한 탐욕적 해결법이 있는지 고민하자.
2. 시뮬레이션 유형에서나 뭔가 방향을 설정해서 이동하는 문제에선 dx,dy를 별도의 리스트를 만들어서 관리하면 매우 좋다. (Chapter 4의 3번 문제)
3. 시뮬레이션 유형은 진짜 그냥 문제 그대로를 순서대로 구현하려고 노력하자.

---

## DFS/BFS

1. stack과 queue의 개념에 대해 잘 알고 있도록 하자.
* stack은 First In Last Out 혹은 Last In First Out 구조이다. 
* queue는 First In First Out 구조이다.
* queue는 기본 라이브러리 말고 **collections 모듈에서 제공하는 deque**를 활용하자.

2. Recursive 함수를 잘 사용하자.

    이때 recursive 함수의 느낌은 이런 것 같다. 어떤 멈춤 지점을 고려해서 그 곳에 return을 걸어 놓고,
함수들을 연속적으로 불러 한층씩 아래로 쌓는다. 그리고 멈춤 지점에서부터 역으로 한층씩 올라오면서 
return에 값을 내놓는 느낌이랄까..!
    factorial의 예제를 들면, 

    ```python
    def factorial_recursive(n):
    # return 을 통해서 쫙 실행되고 찹찹찹 올라가는 느낌.
    if n <= 1 :
        return 1
    # n! = n * (n-1)!

    return n*factorial_recursive(n-1)
    ```


    위 함수에서 n=5라고 하면, 순서는 다음과 같이 전개 될 것이다.
    factorial_recursive(5) -> factorial_recursive(4) -> factorial_recursive(3)
-> factorial_recursive(2) -> factorial_recursive(1) -> return 1

    n=1 일 때, return 1이 나오게 되고 역으로 올라가면서 return에 값을 미친다.  
    return 1 -> return 2x1 = 2-> return 3x2 = 6 -> return 4x6 = 24 -> return 5x24 = 120

3. DFS는 Depth, First Search의 약자로써 가장 깊은 곳 부터 탐색하는 알고리즘이고, Stack 구조를 사용한다.
 * 깊게 들어가기 위해서 recursive 함수를 사용하게 된다.
4. BFS는 Breadth, First Search의 약자로써 가장 가까운 노드부터 탐색하는 알고리즘이고, Queue 구조를 사용한다.
 * 주변 탐색이므로 깊게 들어갈 필요가 없기 때문에, recursive 함수를 사용하지 않는다. 

5. 2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔서 생각해보려고 노력하자.

---

# 정렬(Sorting)

## 선택 정렬(Selection Sort)
1. 시간 복잡도는 $O(N^2)$ 이다. 
2. 모든 원소를 비교하고 위치를 바꾸다보니, 모든 정렬 방법 중 가장 느린 것 같다. 
3. 그러나, 종종 코드에서 특정 리스트에서 가장 작은 데이터를 찾는 일이 잦다고 하니, 종종 쓰인다고 한다.

## 삽입 정렬(Insertion Sort)
1. 시간 복잡도는 최대 $O(N^2)$으로 선택 정렬과 같지만, 리스트가 정렬되어 있는 상태라면 $O(N)$까지 줄어든다.
2. 리스트가 만약 거의 정렬된 상태로 주어진다면 삽입 정렬이 아주 강력히 빠르게 작동하므로 애용하자.

## 퀵 정렬(Quick Sort)
1. 시간 복잡도는 평균적으로 $O(NlogN)$이지만 최악의 경우, 최대 $O(N^2)$까지 증가할 수 있다. 
그때는 보통 데이터가 잘 정렬되어있을 경우 이다. 이는 [삽입 정렬](#삽입 정렬(Insertion Sort))과 반대이다.

## 계수 정렬(Count Sort)
1. 시간 복잡도는 $O(N+K)$ 이다. 
2. 되게 빠르게 정렬되는데, 단점은 다음과 같은 조건이 있다는 것이다.
* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때
3. 이 정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때** 아주 강력하게 작용한다.
4. 데이터의 크기가 한정되어있고, 데이터가 많이 중복되어있고, 정렬해야하는 데이터의 개수가 매우 많을 때도 효과적이다.

정렬과 관련된 문제는 별도의 요구가 없이 단순 정렬은 기본 라이브러리인 .sort()와 sorted(array,key=function)를 이용하자.
만약 데이터 범위가 한정되어있고 더 빠르게 동작해야하면 계수 정렬을 쓰자.

---

# 이진 탐색

## 순차 탐색(Sequential Search)
1. 순차적으로 데이터를 탐색한다는 의미를 갖는다.
2. 데이터의 수가 N이라고 할 때, N번 비교를 하며 데이터를 찾기 때문에 시간 복잡도는 $O(N)$이다.

## 이진 탐색(Binary Search)
1. 내부 데이터들이 정렬되어 있어야만 사용 가능하다. 
2. 데이터를 매우 빠르게 찾아낼 수 있다.
3. 데이터를 탐색할 때, 확인할 데이터의 수가 절반씩 줄어들어, 시간 복잡도가 $O(NlogN)$이다.
4. 구현 방법에는 **재귀**와 **반복**이 있다.
5. 출제되는 빈도가 꽤나 높으니 코드를 잘 외우두자.
6. 탐색 범위가 2000만을 넘어가거나 데이터의 수가 크면 이진 탐색처럼 $O(NlogN)$의 속도를 내는 알고리즘을 떠올리자.

