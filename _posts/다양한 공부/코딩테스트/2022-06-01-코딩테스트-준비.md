---
title: "코딩테스트 준비를 위한 과정"
categories:
  - 코딩테스트
toc: true
---

# 기본적으로 알아야 할 것
1. 최대한 for 문을 사용하지 않는 것이 시간적으로 이득이다.
2. numpy를 이용하지 못할 때가 있을 수도 있다. 그때는 대비하여 파이썬의 
기본 라이브러리들에 대해 빠삭하게 공부하자. [링크](https://docs.python.org/ko/3.8/library/index.html)
 * 자주쓰는 **random, sort** 등을 항상 생각하자.
 * 5 2 처럼 입력을 받을 때 n,m = map(int,input().split()) 를 사용하자.
 * 기본 함수 중 min, max를 잘 활용하고, 기본적인 문법은 다음과 같다. 
 ```python
  min(a) # 리스트 a에서 가장 작은 수를 추출
  min(a,b) # 실수 a,b 중 작은 놈을 추출
  max(a) # 리스트 a에서 가장 작은수를 추출
  max(a,b) # 실수 a,b 중 큰 놈을 추출
 ```
 
3. 파이썬은 메모리 제한을 고려하려면 만약 int형 데이터의 list의 길이가 1000만이 되면 메모리는 40MB를 잡아먹는 것을 알자.
4. 파이썬의 계산시간을 고려하려면 대충 1초에 2000만번의 연산을 수행한다고 생각하자. 특히 제한시간이 1초인데 데이터의 개수가 100만개 정도이면 시간 복잡도는 O(NlogN)이내의 알고리즘으로 문제를 풀어야한다. 따라서 시간제한과 데이터의 개수를 먼저 확인한 다음에 어느정도의 시간 복잡도의 알고리즘으로 문제를 풀지 예측하는 습관을 가져야한다.

# 알고리즘별 정리

## 그리디 및 시뮬레이션

1. 문제 유형을 바로 파악하기 어려우면 그리디 알고리즘을 의심하고 문제해결을 위한 탐욕적 해결법이 있는지 고민하자.
2. 시뮬레이션 유형에서나 뭔가 방향을 설정해서 이동하는 문제에선 dx,dy를 별도의 리스트를 만들어서 관리하면 매우 좋다. (Chapter 4의 3번 문제)
3. 시뮬레이션 유형은 진짜 그냥 문제 그대로를 순서대로 구현하려고 노력하자.
 
## DFS/BFS

1. stack과 queue의 개념에 대해 잘 알고 있도록 하자.
* stack은 First In Last Out 혹은 Last In First Out 구조이다. 
* queue는 First In First Out 구조이다.
* queue는 기본 라이브러리 말고 **collections 모듈에서 제공하는 deque**를 활용하자.

2. Recursive 함수를 잘 사용하자.

    이때 recursive 함수의 느낌은 이런 것 같다. 어떤 멈춤 지점을 고려해서 그 곳에 return을 걸어 놓고,
함수들을 연속적으로 불러 한층씩 아래로 쌓는다. 그리고 멈춤 지점에서부터 역으로 한층씩 올라오면서 
return에 값을 내놓는 느낌이랄까..!
    factorial의 예제를 들면, 

    ```python
    def factorial_recursive(n):
    # return 을 통해서 쫙 실행되고 찹찹찹 올라가는 느낌.
    if n <= 1 :
        return 1
    # n! = n * (n-1)!

    return n*factorial_recursive(n-1)
    ```


    위 함수에서 n=5라고 하면, 순서는 다음과 같이 전개 될 것이다.
    factorial_recursive(5) -> factorial_recursive(4) -> factorial_recursive(3)
-> factorial_recursive(2) -> factorial_recursive(1) -> return 1

    n=1 일 때, return 1이 나오게 되고 역으로 올라가면서 return에 값을 미친다.  
    return 1 -> return 2x1 = 2-> return 3x2 = 6 -> return 4x6 = 24 -> return 5x24 = 120

3. DFS는 Depth, First Search의 약자로써 가장 깊은 곳 부터 탐색하는 알고리즘이고, Stack 구조를 사용한다.
 * 깊게 들어가기 위해서 recursive 함수를 사용하게 된다.
4. BFS는 Breadth, First Search의 약자로써 가장 가까운 노드부터 탐색하는 알고리즘이고, Queue 구조를 사용한다.
 * 주변 탐색이므로 깊게 들어갈 필요가 없기 때문에, recursive 함수를 사용하지 않는다. 

5. 2차원 배열에서의 탐색 문제를 만나면 그래프 형태로 바꿔서 생각해보려고 노력하자.

