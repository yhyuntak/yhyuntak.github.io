---
title: "7569 토마토"
excerpt : 기본 BFS에서 많이 변형된 정도
categories:
  - 코딩테스트
  - BFS
toc: true
---
  
# 1. 문제

문제는 [링크](https://www.acmicpc.net/problem/7569)를 들어가면 볼 수 있다.

# 2. 정답 코드

문제의 내 정답 코드는 다음과 같다.

```python
import sys
read =sys.stdin.readline
from collections import deque

M,N,H = map(int,read().split())

graph = [[[] for _ in range(N)] for _ in range(H)] # 제일 바깥부터 순서대로 H,N,N이다

# 모든 칸에서 토마토가 존재하는지 확인하고 우선적으로 QUEUE에 넣어야한다.
q = deque()
for h in range(H):
    for n in range(N):
        graph[h][n] = list(map(int,read().split()))
        tomato_temp = [i for i,tomato in enumerate(graph[h][n]) if tomato == 1]
        if len(tomato_temp) >= 1 : # 토마토가 있다면 queue에 정보를 넣자
            for t in tomato_temp :
                q.append([h,n,t])

# 움직임 설정
# 상 하 좌 우 위 아래
dx = [0,0,-1,1,0,0]
dy = [-1,1,0,0,0,0]
dh = [0,0,0,0,1,-1]

days = 0
while q :
    # 하루에 영향을 끼칠 수 있는 토마토는 전부 영향을 끼쳐야하므로
    # for문을 넣어서 전부 사용되게끔 유도
    for i in range(len(q)):
        now_tomato = q.popleft()
        # 6가지 행동을 파악
        for j in range(6):
            nh = now_tomato[0] + dh[j]
            ny = now_tomato[1] + dy[j]
            nx = now_tomato[2] + dx[j]
            # 상자의 정상 범주 안에 있어야하는 조건 하에 진행
            if 0<=nx<M and 0<=ny<N and 0<=nh<H :
                # 주변의 토마토가 있다면(0) 그것을 익었다고 처리하고(1)
                # queue에 넣자
                if graph[nh][ny][nx] == 0 :
                    graph[nh][ny][nx] = 1
                    q.append([nh,ny,nx])

    days += 1

zero_count = 0
for h in range(H):
    for n in range(N):
        zero_count += graph[h][n].count(0)
if zero_count == 0 :
    print(days-1)
else :
    print(-1)


```

<br/><br/><br/>

# 3. 문제 풀이

이 문제는 [토마토문제](https://yhyuntak.github.io/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/bfs/7576_%ED%86%A0%EB%A7%88%ED%86%A0/)
에서 좀더 업그레이된 버전이지만, 사실 쉽다. BFS를 다룰줄만 알면 무난히 풀 수 있는 문제.
따라서 딱히 설명할 것은 없지만, 리스트 안에 해당 요소가 있는지 파악하기 위해 이번에 새로 쓴
문법이 있는데, 그것은 다음과 같다.
```python
tomato_temp = [i for i,t in graph[h][n] if t == 0]
```
앞으로도 자주 쓸 것 같으니 잘 파악해두자.
