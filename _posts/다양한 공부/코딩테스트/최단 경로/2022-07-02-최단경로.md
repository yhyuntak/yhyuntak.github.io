---
title: "최단 경로"
categories:
  - 코딩테스트
  - 최단 경로
toc: true
---
  
# 최단 경로
최단 경로란, 가장 짧은 경로를 찾는 알고리즘을 얘기하고, 가장 대표적인 알고리즘은 다음과 같다.
1. 다익스트라 최단 경로
2. 플로이드 워셜 알고리즘

<br/>

## 다익스트라 최단 경로 알고리즘
매번 가장 비용이 적은 노드를 선택해 다음의 과정을 반복한다.
1. 출발 노드를 설정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
5. 3,4를 반복

다익스트라 알고리즘은 일종의 그리디 알고리즘이라고 한다.
구현 방법은 2가지가 있는데, 구현하기가 조금 까다롭지만 빠르게 동작하는 코드에 대해 무조건적으로 외우는 것이 좋다고 한다.
**힙큐를 이용한 우선순위 큐를 구성하는 방법**에 대해 외우자.

<br/>

## 플로이드 워셜 알고리즘

다익스트라는 "**한 지점**에서 다른 특정 지점까지의 최단 경로를 구해야하는 경우"에 사용하고, 
이것은 "**모든 지점**에서 다른 모든 지점까지의 최단 경로를 모두 구해야하는 경우"에 사용된다.

<br/><br/><br/>


# 정렬(Sorting)

<br/>

## 선택 정렬(Selection Sort)
1. 시간 복잡도는 $O(N^2)$ 이다. 
2. 모든 원소를 비교하고 위치를 바꾸다보니, 모든 정렬 방법 중 가장 느린 것 같다. 
3. 그러나, 종종 코드에서 특정 리스트에서 가장 작은 데이터를 찾는 일이 잦다고 하니, 종종 쓰인다고 한다.

<br/>

## 삽입 정렬(Insertion Sort)
1. 시간 복잡도는 최대 $O(N^2)$으로 선택 정렬과 같지만, 리스트가 정렬되어 있는 상태라면 $O(N)$까지 줄어든다.
2. 리스트가 만약 거의 정렬된 상태로 주어진다면 삽입 정렬이 아주 강력히 빠르게 작동하므로 애용하자.

<br/>

## 퀵 정렬(Quick Sort)
1. 시간 복잡도는 평균적으로 $O(NlogN)$이지만 최악의 경우, 최대 $O(N^2)$까지 증가할 수 있다. 
그때는 보통 데이터가 잘 정렬되어있을 경우 이다. 이는 [삽입 정렬](#삽입 정렬(Insertion Sort))과 반대이다.

<br/>

## 계수 정렬(Count Sort)
1. 시간 복잡도는 $O(N+K)$ 이다. 
2. 되게 빠르게 정렬되는데, 단점은 다음과 같은 조건이 있다는 것이다.
* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때
3. 이 정렬은 **동일한 값을 가지는 데이터가 여러 개 등장할 때** 아주 강력하게 작용한다.
4. 데이터의 크기가 한정되어있고, 데이터가 많이 중복되어있고, 정렬해야하는 데이터의 개수가 매우 많을 때도 효과적이다.

정렬과 관련된 문제는 별도의 요구가 없이 단순 정렬은 기본 라이브러리인 .sort()와 sorted(array,key=function)를 이용하자.
만약 데이터 범위가 한정되어있고 더 빠르게 동작해야하면 계수 정렬을 쓰자.
